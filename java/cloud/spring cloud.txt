YAML 将属性加载到内存中保存的时候是有序的，所以当配置文件中的信息需要具备顺序含义时， 
    YAML 的配置方式比起 properties 配置文件更有优势。
@Value 注解加载属性值的时候可以支持两种表达式来进行配置
    ${}或#{}
java -jar xxx.jar --server.part=8888 连续的两个减号就是对配置文件中的属性值进行赋值标识

多环境配置文件
    满足application-xxx.properties的格式，如application-dev.properties
        并在application.properties中设置spring.profile.actice=xxx，
        （默认为dev）以使用其中一个配置文件的内容
各种方式配置的优先级由高到低
    命令行传入
    SPRING_APPLICATION_JSON系统环境变量（以json格式配置）
    java:comp/env中JNDI的属性
    java系统属性，通过System.getProperties()获取的内容
    操作系统环境变量
    通过random.*配置的随机属性
    jar包之外通过application-xxx.properties配置的内容
    jar包之内通过application-xxx.properties配置的
    jar包外的application.properties或yml
    jar包内的application.properties或yml
    @Configuration注解修饰的类中，通过 @PropertySource注释的属性
    应用默认属性，使用SpringApplication.setDefaultProperties设置的内容


Spring Cloud Eureka
    注册中心， 每个服务单元向注册中心登记自己提供的服务，将主机与端口号、
            版本号、通信协议等一些附加信息告知注册中心
        服务注册中心还需要以心跳的方式去监测清单中的服务是否可用
    服务间的调用不再通过指定具体的实例地址来实现， 而是通过向服务名发起请求调用实现
        C -> A : C请求注册中心获取所有服务的实例清单，再以某种轮询策略（负载均衡）取出一个实例进行调用
    Netflix推荐每个可用的区域运行一个Eureka服务端，通过它来形成集群
        服务注册中心通过异步模式互相复制各自的状态，故每个实例关于所有服务的状态有细微差别
    EurekaServer的【高可用】实际上就是将自己作为服务向其他服务注册中心注册自己

    图1
    提供方
        服务注册：服务提供方启动时向eureka server发送rest请求，注册自身信息
            eureka.client.register-with-eureka=true默认值，即向eureka注册
        服务同步
            eureka收到注册请求时向其他注册中心转发
        服务续约：服务提供者持续发送心跳，以告知注册中心“我还活着”
            eureka.instance.lease-renewal-interval-in-seconds: 30 #心跳默认值
            eureka.instance.lease-expiration-duration-in-seconds: 90 #失效默认值
    调用方
        服务获取：eureka server会维护一只读清单并30s更新一次，以返回给要获取服务的调用方
            eureka.client.fetch-registry=true 调用方必需的
            eureka.client.registry-fetch-interval-seconds=30 #默认值，修改缓存清单更新时间 
        服务下线：服务实例正常关闭时会向eureka server发送请求，告知之
    注册中心
        失效剔除：默认每隔60s将清单中超过90s没有续约的服务剔除
        自我保护：本地调试时eureka面板上常常会遇到下述警告，当心跳失败比率在15分钟内低于85%时，
            （单机调试容易满足，生产环境往往由于网络不稳定），会将注册信息保护，让其不会过期。
            EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.
            故在调试期间常将自我保护关闭
                eureka.server.enable-self-preservation=false
    
    实例名配置
        实现在同一主机上， 不指定端口就能轻松启动多个实例的效果
        eureka.instance.instanceid=${spring.application.name}:${random.int}}
    健康监测
        pom中引入 spring-boot-starter-actuator
        配置文件 eureka.client.healthcheck.enabled=true
        在设置context-path后，要配置info和health的路径
            management.context-path=/hello
            eureka.instance.statusPageUrlPath=${management.context-path}/info
            eureka.instance.healthCheckUrlPa七h=${management.context-path}/health
