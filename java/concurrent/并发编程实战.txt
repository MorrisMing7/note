简介
    安全性
        结果的可预料，"永远不会发生糟糕的事情". 
    活跃性
        某件正确的事情最终会发生, 单线程的活跃性问题是可能无意中造成无限循环, 多线程则对应有死锁, 饥饿等.

*************************
* 线程安全性 对象的共享 *
*************************
    无状态的对象一定是线程安全的
    
    竞态条件 Race Condition
        当某个计算的正确性取决于多个线程交替执行的时序时, 就会发生竞态条件. 即是否正确要取决于运气. 
        最常见的竞态条件类型是 "先检查后执行" 操作.

    volatile
        声明变量的共享，阻止此变量上的操作与其他内存操作的重排序。并且volatile变量不会被缓存到寄存器或其他处理器不可见的地方。
        因此，读取的volatile类型变量总是其最新写入的值。
    server模式的JVM会比client模式的做更多的优化
        volatile boolean asleep；
        ...
            while(!asleep)
                countSomeSheep();
        上述代码中，若asleep未声明volatile，在server模式下，JVM会将asleep的判断提升到循环外，导致一个无限循环。
        
    volatile常用作某个操作的完成、终端或状态标志
        当且仅当满足以下条件时，才应该使用volatile
            对变量的写入操作不依赖于当前值，或能保证只有单个线程写入；
            该变量不会与其他状态变量一起纳入不变性条件中；
            访问时不需要加锁。
        volatile只保证可见性, 而不保证原子性
    发布与逸出
        发布：使对象能够在当前作用域之外的代码中使用。
        逸出：某个不该发布的对象被发布。
        public class A{
            public A(EventSource es){
                es.registerListener(new EventListener(){
                    public void on Event(Event e){doSomething(e);}
                });
            }
        }
        当内部的EventListener实例发布时，外部的A实例也逸出了。
        public class SafeListener{
            private final EventListener listener;
            private SafeListener(){
                listener = new EventListener(){
                    public void onEvent(Event e){doSome(e);}
                };
            }
            public static SafeListener newInstance(EventSource es){
                SafeListener sl = new SafeListener();
                es.registerListener(safe.listener);
                return sl;
            }
        }

    线程封闭  
        仅在单线程中访问数据。
        JDBC中的Connection对象不要求是线程安全的，线程从连接池(连接池是线程安全的)获取connection对象，用其处理请求，隐含的将Connection对象封闭在线程中。
        Ad-hoc封闭
            完全由程序实现来承担
        栈封闭
            只能通过局部变量才能访问对象。局部变量是封闭在执行线程中的，程序员只需确保被引用对象不会逸出。
            需要明确说明不可被逸出的需求，以防后续开发人员错误的将其逸出。
        ThreadLocal类
            通常用于防止对可变单实例变量或全局变量进行共享。
            例：在单线程应用程序中可能需要维持一个全局的数据库连接，并且在程序启动时初始化之，从而避免调用每个方法都要传入一个Connection对象。
                private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>(){
                        public Connection initialValue(){return DriverManager.getConnection(DB_URL);}
                    };
                public static Connection getConnnection(){return connectionHolder.get();}
            当某个频繁执行的操作需要一个临时对象，比如缓冲区，而又希望避免每次都重新分配该对象时，也可使用这种技术。
            初次调用get方法时，就会initialValue来获取其初值。ThreadLocal<T>概念类似于Map<Thread,T>，但其实现并非Map，线程结束后，值会被回收。
    不变性 
        不可变对象一定是线程安全的。
        满足以下条件即为不可变对象
            对象创建以后其状态不能修改；
            对象的所有域都是final型；
            对象时正确创建的（创建期间this引用没有逸出）
        volatile发布不可变对象
            例：获取某个数的因式分解（常常反复求解同一值的情形）
                public class VolatileCachedFactorizer implements Servlet{
                    private volatile OneValueCache cache = new OneValueCache(null,null);//cache 用于缓存上次求解的值，用于下次直接获取结果
                    public void service(ServletRequest req, ServletResponse resp){
                        BigInteger i = extractFromRequest(req);
                        BigInteger[] factors = cache.getFactors(i);
                        if(factors == null){facotrs = factor(i); cache = new OneValueCache(i,factors);}
                        encodeInroResponse(resp,factors);
                    }
                }
    安全发布    
        可变对象必须通过安全的方式发布，即意味着在发布和使用的线程中必须使用同步。
        一个正确构造的对象可以通过以下方式安全发布
            在静态初始化函数中初始化一个对象的引用；
            将对象引用保存到volatile域或者AtomicReference对象中；
            将对象引用保存到某个正确构造的对象的final域中
            将对象引用保存到一个由锁保护的域中
          不安全的发布
            public Holder holder;
            public void initialize(){
                holder = new Holder(1);
            }//在另一个线程中看到的holder肯是失效的，导致另一个线程调用assertSanity()会抛出错
            public class Holder{
                private int n;
                public Holder(int n){this.n = n;}
                public void assertSanity(){if(n!=n) throw new AssertionError("This statement is false");}
            }
        要发布一个静态构造对象，最简单与安全的方式是使用静态初始化器
            public static Holder holder = new Holder(xx);//类的初始化阶段执行
        事实上的不可变对象
            必须通过安全方式来发布
        可变对象
            不仅必须通过安全方式来发布，而且必须是线程安全的或由锁保护。

        共享对象的策略
            线程封闭：只由一个线程拥有，对其他线程不可见
            只读共享：任何线程不可修改，则无需额外同步
            线程安全共享：在内部实现同步，通过对象公有接口访问而无需进一步同步
            保护对象：只能通过持有特定锁来访问，包括封装在其他线程安全对象中的对象，以及已发布且由特定锁保护的对象
******************
**    对象组合
******************
    线程安全类的三个要素
        构成对象状态的所有变量
        约束状态变量的不变性条件
        状态变量的并发访问策略
    实例封闭
        public class PersonSet{
            private final Set<Person> mSet = new HashSet<Person>();
            public synchronized void add(Person p){mSet.add(p);}
            public synchronized boolean contains(Person p){return mSet.contains(p);}
        }
        此类并未对Person类做任何安全性假设，若Person是可变的，那么从PersonSet中获取的Person对象还需要额外的同步。
    java监视器模式
        public class A{
            private final Object myLock = new Object();
            @GuardedBy("myLock") MyClass mc;
            void doSomething(){
                synchronized(myLock){/*mc的操作*/}
            }
        }
    组合・向现有类添加一个原子操作
        public class ImprovedList<T> implements List<T>{
            private final List<T> list;
            public ImprovedList(List<T> list){this.list = list;}
            public synchronized boolean putIfAbsent(T x){
                boolean contains = list.contains(x);
                if(contains) list.add(x);
                return !contains;
            }
            public synchronized void clear(){list.clear();}
            //...按照类似的方式委托List的其他方法
        }
****************
基础构建模块
****************
    同步容器类
        对每个公有方法进行同步，使得每次只有一个县城可以访问容器的状态
        此类容器在进行一些常见的复合操作：迭代、跳转(按指定顺序找到下个元素)、条件运算(如：若没有则添加) 时，
            如果有其他线程并发的修改容器时，可能会出现意料之外的行为
        隐藏的迭代器
            System.out.println("set:"+xSet);//隐式的迭代了xSet
            其他的：当容器作为另一个容器的元素或键值时，容器的hashcode与equals也会间接地执行迭代操作
                containsAll、removeAll、retainAll、以及把容器作为参数的构造函数， 都会对容器迭代
    并发容器
        ConcurrentHashMap 使用粒度更细的加锁来提高并发(分段锁)
            ConcurrentMap<> 接口中包含了常见的复合操作
                V putIfAbsent(K key, V value); //仅当没有映射值时插入
                boolean remove(K key, V value); //仅当映射到v时移除
                boolean replace(K key, V oldValue, V newValue); //仅当映射到旧值时替换
                V replace(K key, V newValue);  //仅当映射到某个值时替换
        CopyOnWriteArrayList
            正确的发布一个事实上不可变的对象。故访问对象时无需进一步同步；
            每次修改时，创建并发布一个新的容器的副本；
            用于迭代远多于修改的情形：如事件通知，分发通知时需要迭代已注册的监听器链表，调用每个监听器；而注册与修改操作远远少于接受事件通知的操作。
        
    阻塞队列・生产者-消费者
        ******************** 队列接口*******************************
        	    抛出异常	false/null  阻塞	超时
        插入	add(e)	    offer(e)	put(e)	offer(e, time, unit)
        移除	remove()	poll()	    take()	poll(time, unit)
        检查	element()	peek()	    不可用	不可用
        /**生产者将文件添加到阻塞队列*/
        public class Producer implements Runnable{
            private final BlockingQueue<File> fileQueue;
            private final FileFilter fileFilter;
            private final File root;
            public void run(){
                try{ crawl(root);}
                catch (InterruptedException e){ Thread.currentThread().interruput();}
            }
            private void crawl(File root) throws InterruptedException{
                File[] entries = root.listFiles(fileFilter);
                if(entries != null){
                    for(File entry: entries)
                        if(entry.isDirectory()) crawl(entry);
                        else if(!alreadyIndexed(entry))
                            fileQueue.put(entry);
                }
            }
        }
        /**消费者从队列中取出文件做一定操作*/
        public class Customer implements Runnable{
            private final BlockingQueue<File> queue;
            public void run(){
                try{ while(true) indexFile(queue.take()); }
                catch (InterruptedException e){
                    Thread.currentThread().interrupt();
                }
            }
        } 
        /**启动*/
        public static void startIndexing(File[] roots){
            BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
            FileFilter filter = new FileFilter(){
                public boolean accept(File file){return true;}
            };
            for(File root:roots)
                new Thread(new Producer(queue,filter,root)).start();
            for(int i=0;i<N_CONSUMERS;i++)
                new Thread(new Customer(queue)).start();
        }
        串行线程封闭
            对象所有权交付，安全的发布对象来转移所有权
        双端队列・工作密取
            如果一个消费者完成自己队列的工作，可以从另个队列的队尾获取工作

    阻塞方法与中断方法
        当代码中调用了一个将抛出InterruptException的方法时，方法就变成一个阻塞方法，并且必须要处理中断响应：
            传递之：不捕获或捕获后进行简单处理并再次抛出，将此异常传递给调用者；
            恢复中断：有事不能抛出InterruptedException，如代码是Runnable的一部分。捕获之，恢复中断状态。
                public class TaskRunnable implements Runnable{
                    BlockingQueue<Task> queue;
                    public void run(){
                        try{ process(queue.take());}
                        catch (InterruptedException e){ Thread.currentThread().interrrupt();}//恢复被中断的状态
                    }
                }
           
        中断线程: 一个线程将把中断看作一个终止请求，
            这种线程的run方法遵循如下形式：
                public void run() {
                    try {
                        ...
                        /*不管循环里是否调用过线程阻塞的方法如sleep、join、wait，这里还是需要加上
                          !Thread.currentThread().isInterrupted()条件，虽然抛出异常后退出了循环，显
                          得用阻塞的情况下是多余的，但如果调用了阻塞方法但没有阻塞时，这样会更安全、更及时。*/
                        while (!Thread.currentThread().isInterrupted()&& more work to do) { do more work  }
                    } catch (InterruptedException e) {
                        //线程在wait或sleep期间被中断了
                    } finally {
                        //线程结束前做一些清理工作
                    }
                }                
            如果try在while循环里时，因该在catch块里重新设置一下中断标示，因为抛出InterruptedException异常后，中断标示位会自动清除
                public void run() {
                    while (!Thread.currentThread().isInterrupted()&& more work to do) {
                        try { ...; sleep(delay); } 
                        catch (InterruptedException e) {Thread.currentThread().interrupt(); }//重新设置中断标示
                    }
                }
    同步工具类        
        闭锁
                确保某个计算在所有资源都被初始化后才继续进行。或某个操作的所有参与者都就绪后才继续执行。
          CountDownLatch
            /** 创建nThreads个线程，运行task，统计运行时间*/
            public long timeTasks(int nThreads, final Runnable task) throws InterruptedException{
                final CountDownLatch startGate = new CountDownLatch(1);
                final CountDownLatch endGate = new CountDownLatch(nThreads);
                for (int i=0; i<nThreads; i++){
                    Thread t = new Thread(){  public void run(){
                            try{ starGate.await();
                                try{ task.run();}
                                finally{ endGate.countDown();}
                            } catch (InterruptedException ignored){}
                    }};
                    t.start();
                long start = System.nanoTime();
                starGate.countDown();
                endGate.await();
                long end = System.nanoTime();
                return end-start;
            }
          FutureTask
            可生成结果的计算。计算通过Callable实现，可处于3种状态：等待运行，正在运行，运行完成。
            Future.get()的行为：完成则取回计算结果，否则阻塞到任务完成，取回结果或抛出异常。
                public class Preloader{
                    private final FutureTask<ProductInfo> future = new FutureTask<ProductInfo>(
                        new Callable<ProductInfo>(){ public ProductInfo call() throws DataLoadException {return loadProductInfo();}
                    });
                    private final Thread loaderThread = new Thread(future);
                    public void start(){ loaderThread.start();}
                    public ProductInfo get() throws DataLoadException, InterruptedException{
                        try{ return future.get(); }
                        catch (ExecutionException e){
                            Throwable cause = e.getCause();
                            if(cause instaceof DataLoadException)
                                throw (DataLoadException) cause;
                            else throw launderThrowable(cause);
                        }
                    }
                }
        信号量
            Semaphore种管理者一组虚拟许可，初始数量由构造函数指定。执行操作是先获取许可，使用以后释放许可。若当前没有许可acquire则阻塞至有许可(或被中断、超时)。初始值为1的Semaphore可以用作互斥体(mutex)，且具备不可重入的加锁语义。
            用以控制访问"某个特定资源"或"执行指定操作"的数量，实现某种资源池，对容器施加边界
                public class BoundedHashSet<T> {
                    private final Set<T> set;
                    private final Semaphore sem;
                    public BoundedHashSet(int bound){
                        this.set = Collections.synchronizedSet(new HashSet<T>());
                        this.sem = new Semaphore(bound);
                    }
                    public boolean add(T o) throws InterruptedException{
                        sem.acquired();
                        boolean wasAdded = false;
                        try{ wasAdded = set.add(o); return wasAdded;}
                        finally{ if(!wasAdded) sem.release(); }
                    }
                    public boolean remove(T o){
                        boolean wasRemoved=set.remove(o);
                        if(wasRemoved) sem.relase();
                        return wasRemoved;
                    }
                }
        栅栏
            Barrier类似于闭锁，所有事件到达同一位置时才继续执行，即等待其他线程。
            CyclicBarrier 
                CyclicBarrier(int parties) 
                CyclicBarrier(int parties, Runnable barrierAction) 
                    parties为线程数量，barrierAction为所有线程到达后执行内容
                await()
    构建高效可伸缩结果缓存
        public interface Computable<A,V>{ V compute(A arg) throws InterruptedException; }
        public class SomeFunction implements Computable<String, BigInteger> {
            public BigInteger compute(String s){ ...; return xxx; }
        }
        public Memoizer<A,V> implements Computable<A, V> {
            private final ConcurrentMap<A,V> cache = new ConcurrentHashMap<A, FutureTask<V>>();
            private final Computable<A,V> c;
            public Memoizer(Computable<A,V> c){ this.c = c;}
            public V compute(final A arg) throws InterruptedException{
                while(true){
                    Future f = cache.get(arg);
                    if( f==null ){
                        FutureTask<V> ft = new FutureTask<V>(new Callable<V>(){
                            public V call() throws InterruptedException{ return c.compute(arg); }
                        });
                        f = cache.putIfAbsent(arg,ft);//返回arg前一个映射的值，或空值
                        if( f==null){ f=ft; ft.run();}
                    }
                    try{ return f.get(); }
                    catch (CancellationException e){ cache.remove(arg, f); }
                    catch (EcecutionException e){ throw launderThrowable(e.getCause());}
                }
            }
        }
    并发技巧
        尽量声明final，除非需要他们是可变的；
        不可变对象一定是线程安全的；
        封装有助于管理复杂性；
        用锁保护每个可变变量；
        保护同一个不变性条件，用同一个锁；
        复合操作要持有锁；
        在文档中指出非线程安全，或做线程安全的设计；
        同步策略文档化；
****************************************************************

****************************************************************
********************    结构化并发应用程序  ******************** 
****************************************************************

任务执行
    基于Executor的web服务器
        class TaskExecutionWebServer{
            private static final int NTHREADS = 100;
            private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);
            public static void main(String[] args) throws IOException{
                ServerSocket socket = new ServerSocket(80);
                while(true){
                    final Socket connection = socket.accept();
                    Runnable task = new Runnable(){ public void run(){ handleRequest(connetction);} };
                    exec.execute(task);
                }
            }
        }
    支持关闭的Web服务器
        ExecutorService生命周期：运行、关闭、已终止。
        shutdown平缓的关闭：不在接受任务，等待已经提交(包括尚未开始的)的任务完成.
        shutdownNow：取消所有执行中的任务，并不再启动队列中的任务。
        关闭后提交的任务由"拒绝执行处理器"处理，是execute方法抛出RejectedExecutionException。
        所有任务完成后，ExecutorService进入终止状态。
        可以调用awaitTermination来等待其到达终止。
        class LifecycleWebServer{
            private final ExecutorService exec = ...;
            public void start() throws IOException {
                ServerSocket socket = new ServerSocket(80);
                while(!exec.isShutdown()){
                    try{
                        final Socket conn = socket.accept();
                        exec.execute(new Runnable(){publi void run(){ handleRequest(conn);}});
                    }catch (RejectedExecutionException e){
                        if(!exec.isShutdown()) log("task submission rejected", e);
                    }
                }
            }
            public void stop(){ exec.shutdown();}
            void handleRequest(Socket conn){
                Request req = readRequest(conn);
                if( isShutdownRequest(req)) stop();
                else dispatchRequest(req);
            }
        }
    延迟与周期任务
        Timer类：基于绝对时间，因此任务执行对系统时钟变化敏感；
        ScheduledThreadPoolExecutor来代替：基于相对时间调度。
        Timer：只会创建一个线程执行所有定时任务。若任务持续时间过长，则会影响其他TimerTask的定时准确性。例如；周期10ms的任务，若有一个任务执行了40ms，可能此任务执行完后快速连续调用4次或直接失去4次调用。
        若TimerTask抛出一个未检查的异常，则整个Timer被取消。已经被调度但尚未执行的TimerTask不会再执行，新的任务也不能被调度――――"线程泄漏"
            少用Timer
        DelayQueue：只有某个元素逾期之后才能执行take，从DelayQueue中返回的对象根据其延迟时间排序



