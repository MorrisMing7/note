简介
    安全性
        结果的可预料，"永远不会发生糟糕的事情". 
    活跃性
        某件正确的事情最终会发生, 单线程的活跃性问题是可能无意中造成无限循环, 多线程则对应有死锁, 饥饿等.

*************************
* 线程安全性 对象的共享 *
*************************
    无状态的对象一定是线程安全的
    
    竞态条件 Race Condition
        当某个计算的正确性取决于多个线程交替执行的时序时, 就会发生竞态条件. 即是否正确要取决于运气. 
        最常见的竞态条件类型是 "先检查后执行" 操作.

    volatile
        声明变量的共享，阻止此变量上的操作与其他内存操作的重排序。并且volatile变量不会被缓存到寄存器或其他处理器不可见的地方。
        因此，读取的volatile类型变量总是其最新写入的值。
    server模式的JVM会比client模式的做更多的优化
        volatile boolean asleep；
        ...
            while(!asleep)
                countSomeSheep();
        上述代码中，若asleep未声明volatile，在server模式下，JVM会将asleep的判断提升到循环外，导致一个无限循环。
        
    volatile常用作某个操作的完成、终端或状态标志
        当且仅当满足以下条件时，才应该使用volatile
            对变量的写入操作不依赖于当前值，或能保证只有单个线程写入；
            该变量不会与其他状态变量一起纳入不变性条件中；
            访问时不需要加锁。
        volatile只保证可见性, 而不保证原子性
    发布与逸出
        发布：使对象能够在当前作用域之外的代码中使用。
        逸出：某个不该发布的对象被发布。
        public class A{
            public A(EventSource es){
                es.registerListener(new EventListener(){
                    public void on Event(Event e){doSomething(e);}
                });
            }
        }
        当内部的EventListener实例发布时，外部的A实例也逸出了。
        public class SafeListener{
            private final EventListener listener;
            private SafeListener(){
                listener = new EventListener(){
                    public void onEvent(Event e){doSome(e);}
                };
            }
            public static SafeListener newInstance(EventSource es){
                SafeListener sl = new SafeListener();
                es.registerListener(safe.listener);
                return sl;
            }
        }

    线程封闭  
        仅在单线程中访问数据。
        JDBC中的Connection对象不要求是线程安全的，线程从连接池(连接池是线程安全的)获取connection对象，用其处理请求，隐含的将Connection对象封闭在线程中。
        Ad-hoc封闭
            完全由程序实现来承担
        栈封闭
            只能通过局部变量才能访问对象。局部变量是封闭在执行线程中的，程序员只需确保被引用对象不会逸出。
            需要明确说明不可被逸出的需求，以防后续开发人员错误的将其逸出。
        ThreadLocal类
            通常用于防止对可变单实例变量或全局变量进行共享。
            例：在单线程应用程序中可能需要维持一个全局的数据库连接，并且在程序启动时初始化之，从而避免调用每个方法都要传入一个Connection对象。
                private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>(){
                        public Connection initialValue(){return DriverManager.getConnection(DB_URL);}
                    };
                public static Connection getConnnection(){return connectionHolder.get();}
            当某个频繁执行的操作需要一个临时对象，比如缓冲区，而又希望避免每次都重新分配该对象时，也可使用这种技术。
            初次调用get方法时，就会initialValue来获取其初值。ThreadLocal<T>概念类似于Map<Thread,T>，但其实现并非Map，线程结束后，值会被回收。
    不变性 
        不可变对象一定是线程安全的。
        满足以下条件即为不可变对象
            对象创建以后其状态不能修改；
            对象的所有域都是final型；
            对象时正确创建的（创建期间this引用没有逸出）
        volatile发布不可变对象
            例：获取某个数的因式分解（常常反复求解同一值的情形）
                public class VolatileCachedFactorizer implements Servlet{
                    private volatile OneValueCache cache = new OneValueCache(null,null);//cache 用于缓存上次求解的值，用于下次直接获取结果
                    public void service(ServletRequest req, ServletResponse resp){
                        BigInteger i = extractFromRequest(req);
                        BigInteger[] factors = cache.getFactors(i);
                        if(factors == null){facotrs = factor(i); cache = new OneValueCache(i,factors);}
                        encodeInroResponse(resp,factors);
                    }
                }
    安全发布    
        可变对象必须通过安全的方式发布，即意味着在发布和使用的线程中必须使用同步。
        一个正确构造的对象可以通过以下方式安全发布
            在静态初始化函数中初始化一个对象的引用；
            将对象引用保存到volatile域或者AtomicReference对象中；
            将对象引用保存到某个正确构造的对象的final域中
            将对象引用保存到一个由锁保护的域中
          不安全的发布
            public Holder holder;
            public void initialize(){
                holder = new Holder(1);
            }//在另一个线程中看到的holder肯是失效的，导致另一个线程调用assertSanity()会抛出错
            public class Holder{
                private int n;
                public Holder(int n){this.n = n;}
                public void assertSanity(){if(n!=n) throw new AssertionError("This statement is false");}
            }
        要发布一个静态构造对象，最简单与安全的方式是使用静态初始化器
            public static Holder holder = new Holder(xx);//类的初始化阶段执行
        事实上的不可变对象
            必须通过安全方式来发布
        可变对象
            不仅必须通过安全方式来发布，而且必须是线程安全的或由锁保护。

        共享对象的策略
            线程封闭：只由一个线程拥有，对其他线程不可见
            只读共享：任何线程不可修改，则无需额外同步
            线程安全共享：在内部实现同步，通过对象公有接口访问而无需进一步同步
            保护对象：只能通过持有特定锁来访问，包括封装在其他线程安全对象中的对象，以及已发布且由特定锁保护的对象
对象组合
    线程安全类的三个要素
        构成对象状态的所有变量
        约束状态变量的不变性条件
        状态变量的并发访问策略
    实例封闭
        public class PersonSet{
            private final Set<Person> mSet = new HashSet<Person>();
            public synchronized void add(Person p){mSet.add(p);}
            public synchronized boolean contains(Person p){return mSet.contains(p);}
        }
        此类并未对Person类做任何安全性假设，若Person是可变的，那么从PersonSet中获取的Person对象还需要额外的同步。
    java监视器模式
        public class A{
            private final Object myLock = new Object();
            @GuardedBy("myLock") MyClass mc;
            void doSomething(){
                synchronized(myLock){/*mc的操作*/}
            }
        }
    组合・向现有类添加一个原子操作
        public class ImprovedList<T> implements List<T>{
            private final List<T> list;
            public ImprovedList(List<T> list){this.list = list;}
            public synchronized boolean putIfAbsent(T x){
                boolean contains = list.contains(x);
                if(contains) list.add(x);
                return !contains;
            }
            public synchronized void clear(){list.clear();}
            //...按照类似的方式委托List的其他方法
        }

基础构建模块
    同步容器类
        对每个公有方法进行同步，使得每次只有一个县城可以访问容器的状态
        此类容器在进行一些常见的复合操作：迭代、跳转(按指定顺序找到下个元素)、条件运算(如：若没有则添加) 时，
            如果有其他线程并发的修改容器时，可能会出现意料之外的行为
        隐藏的迭代器
            System.out.println("set:"+xSet);//隐式的迭代了xSet
            其他的：当容器作为另一个容器的元素或键值时，容器的hashcode与equals也会间接地执行迭代操作
                containsAll、removeAll、retainAll、以及把容器作为参数的构造函数， 都会对容器迭代
    并发容器
        ConcurrentHashMap 使用粒度更细的加锁来提高并发(分段锁)
            ConcurrentMap<> 接口中包含了常见的复合操作
                V putIfAbsent(K key, V value); //仅当没有映射值时插入
                boolean remove(K key, V value); //仅当映射到v时移除
                boolean replace(K key, V oldValue, V newValue); //仅当映射到旧值时替换
                V replace(K key, V newValue);  //仅当映射到某个值时替换
        CopyOnWriteArrayList
            正确的发布一个事实上不可变的对象。故访问对象时无需进一步同步；
            每次修改时，创建并发布一个新的容器的副本；
            用于迭代远多于修改的情形：如事件通知，分发通知时需要迭代已注册的监听器链表，调用每个监听器；而注册与修改操作远远少于接受事件通知的操作。
        
    阻塞队列・生产者-消费者
        ******************** 队列接口*******************************
        	    抛出异常	false/null  阻塞	超时
        插入	add(e)	    offer(e)	put(e)	offer(e, time, unit)
        移除	remove()	poll()	    take()	poll(time, unit)
        检查	element()	peek()	    不可用	不可用
        /**生产者将文件添加到阻塞队列*/
        public class Producer implements Runnable{
            private final BlockingQueue<File> fileQueue;
            private final FileFilter fileFilter;
            private final File root;
            public void run(){
                try{ crawl(root);}
                catch (InterruptedException e){ Thread.currentThread().interruput();}
            }
            private void crawl(File root) throws InterruptedException{
                File[] entries = root.listFiles(fileFilter);
                if(entries != null){
                    for(File entry: entries)
                        if(entry.isDirectory()) crawl(entry);
                        else if(!alreadyIndexed(entry))
                            fileQueue.put(entry);
                }
            }
        }
        /**消费者从队列中取出文件做一定操作*/
        public class Customer implements Runnable{
            private final BlockingQueue<File> queue;
            public void run(){
                try{ while(true) indexFile(queue.take()); }
                catch (InterruptedException e){
                    Thread.currentThread().interrupt();
                }
            }
        } 
        /**启动*/
        public static void startIndexing(File[] roots){
            BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
            FileFilter filter = new FileFilter(){
                public boolean accept(File file){return true;}
            };
            for(File root:roots)
                new Thread(new Producer(queue,filter,root)).start();
            for(int i=0;i<N_CONSUMERS;i++)
                new Thread(new Customer(queue)).start();
        }
        串行线程封闭
            对象所有权交付，安全的发布对象来转移所有权
        双端队列・工作密取
            如果一个消费者完成自己队列的工作，可以从另个队列的队尾获取工作

    阻塞方法与中断方法
        当代码中调用了一个将抛出InterruptException的方法时，方法就变成一个阻塞方法，并且必须要处理中断响应：
            传递之：不捕获或捕获后进行简单处理并再次抛出，将此异常传递给调用者；
            恢复中断：有事不能抛出InterruptedException，如代码是Runnable的一部分。捕获之，恢复中断状态。
                public class TaskRunnable implements Runnable{
                    BlockingQueue<Task> queue;
                    public void run(){
                        try{ process(queue.take());}
                        catch (InterruptedException e){ Thread.currentThread().interrrupt();}//恢复被中断的状态
                    }
                }
           
        中断线程: 一个线程将把中断看作一个终止请求，
            这种线程的run方法遵循如下形式：
                public void run() {
                    try {
                        ...
                        /*不管循环里是否调用过线程阻塞的方法如sleep、join、wait，这里还是需要加上
                          !Thread.currentThread().isInterrupted()条件，虽然抛出异常后退出了循环，显
                          得用阻塞的情况下是多余的，但如果调用了阻塞方法但没有阻塞时，这样会更安全、更及时。*/
                        while (!Thread.currentThread().isInterrupted()&& more work to do) { do more work  }
                    } catch (InterruptedException e) {
                        //线程在wait或sleep期间被中断了
                    } finally {
                        //线程结束前做一些清理工作
                    }
                }                
            如果try在while循环里时，因该在catch块里重新设置一下中断标示，因为抛出InterruptedException异常后，中断标示位会自动清除
                public void run() {
                    while (!Thread.currentThread().isInterrupted()&& more work to do) {
                        try { ...; sleep(delay); } 
                        catch (InterruptedException e) {Thread.currentThread().interrupt(); }//重新设置中断标示
                    }
                }
    同步工具类
        /** 创建nThreads个线程，运行task，统计运行时间*/
        public long timeTasks(int nThreads, final Runnable task) throws InterruptedException{
            final CountDownLatch startGate = new CountDownLatch(1);
            final CountDownLatch endGate = new CountDownLatch(nThreads);
            for (int i=0; i<nThreads; i++){
                Thread t = new Thread(){  public void run(){
                        try{ starGate.await();
                            try{ task.run();}
                            finally{ endGate.countDown();}
                        } catch (InterruptedException ignored){}
                }};
                t.start();
            long start = System.nanoTime();
            starGate.countDown();
            endGate.await();
            long end = System.nanoTime();
            return end-start;
        }



