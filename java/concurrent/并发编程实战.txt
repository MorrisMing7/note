简介
    安全性
        结果的可预料，"永远不会发生糟糕的事情". 
    活跃性
        某件正确的事情最终会发生, 单线程的活跃性问题是可能无意中造成无限循环, 多线程则对应有死锁, 饥饿等.

*************************
* 线程安全性 对象的共享 *
*************************
    无状态的对象一定是线程安全的
    
    竞态条件 Race Condition
        当某个计算的正确性取决于多个线程交替执行的时序时, 就会发生竞态条件. 即是否正确要取决于运气. 
        最常见的竞态条件类型是 "先检查后执行" 操作.

    volatile
        声明变量的共享，阻止此变量上的操作与其他内存操作的重排序。并且volatile变量不会被缓存到寄存器或其他处理器不可见的地方。
        因此，读取的volatile类型变量总是其最新写入的值。
    server模式的JVM会比client模式的做更多的优化
        volatile boolean asleep；
        ...
            while(!asleep)
                countSomeSheep();
        上述代码中，若asleep未声明volatile，在server模式下，JVM会将asleep的判断提升到循环外，导致一个无限循环。
        
    volatile常用作某个操作的完成、终端或状态标志
        当且仅当满足以下条件时，才应该使用volatile
            对变量的写入操作不依赖于当前值，或能保证只有单个线程写入；
            该变量不会与其他状态变量一起纳入不变性条件中；
            访问时不需要加锁。
        volatile只保证可见性, 而不保证原子性
    发布与逸出
        发布：使对象能够在当前作用域之外的代码中使用。
        逸出：某个不该发布的对象被发布。
        public class A{
            public A(EventSource es){
                es.registerListener(new EventListener(){
                    public void on Event(Event e){doSomething(e);}
                });
            }
        }
        当内部的EventListener实例发布时，外部的A实例也逸出了。
        public class SafeListener{
            private final EventListener listener;
            private SafeListener(){
                listener = new EventListener(){
                    public void onEvent(Event e){doSome(e);}
                };
            }
            public static SafeListener newInstance(EventSource es){
                SafeListener sl = new SafeListener();
                es.registerListener(safe.listener);
                return sl;
            }
        }

    线程封闭  
        仅在单线程中访问数据。
        JDBC中的Connection对象不要求是线程安全的，线程从连接池(连接池是线程安全的)获取connection对象，用其处理请求，隐含的将Connection对象封闭在线程中。
        Ad-hoc封闭
            完全由程序实现来承担
        栈封闭
            只能通过局部变量才能访问对象。局部变量是封闭在执行线程中的，程序员只需确保被引用对象不会逸出。
            需要明确说明不可被逸出的需求，以防后续开发人员错误的将其逸出。
        ThreadLocal类
            通常用于防止对可变单实例变量或全局变量进行共享。
            例：在单线程应用程序中可能需要维持一个全局的数据库连接，并且在程序启动时初始化之，从而避免调用每个方法都要传入一个Connection对象。
                private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>(){
                        public Connection initialValue(){return DriverManager.getConnection(DB_URL);}
                    };
                public static Connection getConnnection(){return connectionHolder.get();}
            当某个频繁执行的操作需要一个临时对象，比如缓冲区，而又希望避免每次都重新分配该对象时，也可使用这种技术。
            初次调用get方法时，就会initialValue来获取其初值。ThreadLocal<T>概念类似于Map<Thread,T>，但其实现并非Map，线程结束后，值会被回收。
    不变性 
        不可变对象一定是线程安全的。
        满足以下条件即为不可变对象
            对象创建以后其状态不能修改；
            对象的所有域都是final型；
            对象时正确创建的（创建期间this引用没有逸出）
        volatile发布不可变对象
            例：获取某个数的因式分解（常常反复求解同一值的情形）
                public class VolatileCachedFactorizer implements Servlet{
                    private volatile OneValueCache cache = new OneValueCache(null,null);//cache 用于缓存上次求解的值，用于下次直接获取结果
                    public void service(ServletRequest req, ServletResponse resp){
                        BigInteger i = extractFromRequest(req);
                        BigInteger[] factors = cache.getFactors(i);
                        if(factors == null){facotrs = factor(i); cache = new OneValueCache(i,factors);}
                        encodeInroResponse(resp,factors);
                    }
                }
    安全发布    
        可变对象必须通过安全的方式发布，即意味着在发布和使用的线程中必须使用同步。
        一个正确构造的对象可以通过以下方式安全发布
            在静态初始化函数中初始化一个对象的引用；
            将对象引用保存到volatile域或者AtomicReference对象中；
            将对象引用保存到某个正确构造的对象的final域中
            将对象引用保存到一个由锁保护的域中
          不安全的发布
            public Holder holder;
            public void initialize(){
                holder = new Holder(1);
            }//在另一个线程中看到的holder肯是失效的，导致另一个线程调用assertSanity()会抛出错
            public class Holder{
                private int n;
                public Holder(int n){this.n = n;}
                public void assertSanity(){if(n!=n) throw new AssertionError("This statement is false");}
            }
        要发布一个静态构造对象，最简单与安全的方式是使用静态初始化器
            public static Holder holder = new Holder(xx);//类的初始化阶段执行
        事实上的不可变对象
            必须通过安全方式来发布
        可变对象
            不仅必须通过安全方式来发布，而且必须是线程安全的或由锁保护。

        共享对象的策略
            线程封闭：只由一个线程拥有，对其他线程不可见
            只读共享：任何线程不可修改，则无需额外同步
            线程安全共享：在内部实现同步，通过对象公有接口访问而无需进一步同步
            保护对象：只能通过持有特定锁来访问，包括封装在其他线程安全对象中的对象，以及已发布且由特定锁保护的对象
******************
**    对象组合
******************
    线程安全类的三个要素
        构成对象状态的所有变量
        约束状态变量的不变性条件
        状态变量的并发访问策略
    实例封闭
        public class PersonSet{
            private final Set<Person> mSet = new HashSet<Person>();
            public synchronized void add(Person p){mSet.add(p);}
            public synchronized boolean contains(Person p){return mSet.contains(p);}
        }
        此类并未对Person类做任何安全性假设，若Person是可变的，那么从PersonSet中获取的Person对象还需要额外的同步。
    java监视器模式
        public class A{
            private final Object myLock = new Object();
            @GuardedBy("myLock") MyClass mc;
            void doSomething(){
                synchronized(myLock){/*mc的操作*/}
            }
        }
    组合・向现有类添加一个原子操作
        public class ImprovedList<T> implements List<T>{
            private final List<T> list;
            public ImprovedList(List<T> list){this.list = list;}
            public synchronized boolean putIfAbsent(T x){
                boolean contains = list.contains(x);
                if(contains) list.add(x);
                return !contains;
            }
            public synchronized void clear(){list.clear();}
            //...按照类似的方式委托List的其他方法
        }
****************
基础构建模块
****************
    同步容器类
        对每个公有方法进行同步，使得每次只有一个县城可以访问容器的状态
        此类容器在进行一些常见的复合操作：迭代、跳转(按指定顺序找到下个元素)、条件运算(如：若没有则添加) 时，
            如果有其他线程并发的修改容器时，可能会出现意料之外的行为
        隐藏的迭代器
            System.out.println("set:"+xSet);//隐式的迭代了xSet
            其他的：当容器作为另一个容器的元素或键值时，容器的hashcode与equals也会间接地执行迭代操作
                containsAll、removeAll、retainAll、以及把容器作为参数的构造函数， 都会对容器迭代
    并发容器
        ConcurrentHashMap 使用粒度更细的加锁来提高并发(分段锁)
            ConcurrentMap<> 接口中包含了常见的复合操作
                V putIfAbsent(K key, V value); //仅当没有映射值时插入
                boolean remove(K key, V value); //仅当映射到v时移除
                boolean replace(K key, V oldValue, V newValue); //仅当映射到旧值时替换
                V replace(K key, V newValue);  //仅当映射到某个值时替换
        CopyOnWriteArrayList
            正确的发布一个事实上不可变的对象。故访问对象时无需进一步同步；
            每次修改时，创建并发布一个新的容器的副本；
            用于迭代远多于修改的情形：如事件通知，分发通知时需要迭代已注册的监听器链表，调用每个监听器；而注册与修改操作远远少于接受事件通知的操作。
        
    阻塞队列・生产者-消费者
        ******************** 队列接口*******************************
        	    抛出异常	false/null  阻塞	超时
        插入	add(e)	    offer(e)	put(e)	offer(e, time, unit)
        移除	remove()	poll()	    take()	poll(time, unit)
        检查	element()	peek()	    不可用	不可用
        /**生产者将文件添加到阻塞队列*/
        public class Producer implements Runnable{
            private final BlockingQueue<File> fileQueue;
            private final FileFilter fileFilter;
            private final File root;
            public void run(){
                try{ crawl(root);}
                catch (InterruptedException e){ Thread.currentThread().interruput();}
            }
            private void crawl(File root) throws InterruptedException{
                File[] entries = root.listFiles(fileFilter);
                if(entries != null){
                    for(File entry: entries)
                        if(entry.isDirectory()) crawl(entry);
                        else if(!alreadyIndexed(entry))
                            fileQueue.put(entry);
                }
            }
        }
        /**消费者从队列中取出文件做一定操作*/
        public class Customer implements Runnable{
            private final BlockingQueue<File> queue;
            public void run(){
                try{ while(true) indexFile(queue.take()); }
                catch (InterruptedException e){
                    Thread.currentThread().interrupt();
                }
            }
        } 
        /**启动*/
        public static void startIndexing(File[] roots){
            BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
            FileFilter filter = new FileFilter(){
                public boolean accept(File file){return true;}
            };
            for(File root:roots)
                new Thread(new Producer(queue,filter,root)).start();
            for(int i=0;i<N_CONSUMERS;i++)
                new Thread(new Customer(queue)).start();
        }
        串行线程封闭
            对象所有权交付，安全的发布对象来转移所有权
        双端队列・工作密取
            如果一个消费者完成自己队列的工作，可以从另个队列的队尾获取工作

    阻塞方法与中断方法
        当代码中调用了一个将抛出InterruptException的方法时，方法就变成一个阻塞方法，并且必须要处理中断响应：
            传递之：不捕获或捕获后进行简单处理并再次抛出，将此异常传递给调用者；
            恢复中断：有事不能抛出InterruptedException，如代码是Runnable的一部分。捕获之，恢复中断状态。
                public class TaskRunnable implements Runnable{
                    BlockingQueue<Task> queue;
                    public void run(){
                        try{ process(queue.take());}
                        catch (InterruptedException e){ Thread.currentThread().interrrupt();}//恢复被中断的状态
                    }
                }
           
        中断线程: 一个线程将把中断看作一个终止请求，
            这种线程的run方法遵循如下形式：
                public void run() {
                    try {
                        ...
                        /*不管循环里是否调用过线程阻塞的方法如sleep、join、wait，这里还是需要加上
                          !Thread.currentThread().isInterrupted()条件，虽然抛出异常后退出了循环，显
                          得用阻塞的情况下是多余的，但如果调用了阻塞方法但没有阻塞时，这样会更安全、更及时。*/
                        while (!Thread.currentThread().isInterrupted()&& more work to do) { do more work  }
                    } catch (InterruptedException e) {
                        //线程在wait或sleep期间被中断了
                    } finally {
                        //线程结束前做一些清理工作
                    }
                }                
            如果try在while循环里时，因该在catch块里重新设置一下中断标示，因为抛出InterruptedException异常后，中断标示位会自动清除
                public void run() {
                    while (!Thread.currentThread().isInterrupted()&& more work to do) {
                        try { ...; sleep(delay); } 
                        catch (InterruptedException e) {Thread.currentThread().interrupt(); }//重新设置中断标示
                    }
                }
    同步工具类        
        闭锁
                确保某个计算在所有资源都被初始化后才继续进行。或某个操作的所有参与者都就绪后才继续执行。
          CountDownLatch
            /** 创建nThreads个线程，运行task，统计运行时间*/
            public long timeTasks(int nThreads, final Runnable task) throws InterruptedException{
                final CountDownLatch startGate = new CountDownLatch(1);
                final CountDownLatch endGate = new CountDownLatch(nThreads);
                for (int i=0; i<nThreads; i++){
                    Thread t = new Thread(){  public void run(){
                            try{ starGate.await();
                                try{ task.run();}
                                finally{ endGate.countDown();}
                            } catch (InterruptedException ignored){}
                    }};
                    t.start();
                long start = System.nanoTime();
                starGate.countDown();
                endGate.await();
                long end = System.nanoTime();
                return end-start;
            }
          FutureTask
            可生成结果的计算。计算通过Callable实现，可处于3种状态：等待运行，正在运行，运行完成。
            Future.get()的行为：完成则取回计算结果，否则阻塞到任务完成，取回结果或抛出异常。
                public class Preloader{
                    private final FutureTask<ProductInfo> future = new FutureTask<ProductInfo>(
                        new Callable<ProductInfo>(){ public ProductInfo call() throws DataLoadException {return loadProductInfo();}
                    });
                    private final Thread loaderThread = new Thread(future);
                    public void start(){ loaderThread.start();}
                    public ProductInfo get() throws DataLoadException, InterruptedException{
                        try{ return future.get(); }
                        catch (ExecutionException e){
                            Throwable cause = e.getCause();
                            if(cause instaceof DataLoadException)
                                throw (DataLoadException) cause;
                            else throw launderThrowable(cause);
                        }
                    }
                }
        信号量
            Semaphore种管理者一组虚拟许可，初始数量由构造函数指定。执行操作是先获取许可，使用以后释放许可。若当前没有许可acquire则阻塞至有许可(或被中断、超时)。初始值为1的Semaphore可以用作互斥体(mutex)，且具备不可重入的加锁语义。
            用以控制访问"某个特定资源"或"执行指定操作"的数量，实现某种资源池，对容器施加边界
                public class BoundedHashSet<T> {
                    private final Set<T> set;
                    private final Semaphore sem;
                    public BoundedHashSet(int bound){
                        this.set = Collections.synchronizedSet(new HashSet<T>());
                        this.sem = new Semaphore(bound);
                    }
                    public boolean add(T o) throws InterruptedException{
                        sem.acquired();
                        boolean wasAdded = false;
                        try{ wasAdded = set.add(o); return wasAdded;}
                        finally{ if(!wasAdded) sem.release(); }
                    }
                    public boolean remove(T o){
                        boolean wasRemoved=set.remove(o);
                        if(wasRemoved) sem.relase();
                        return wasRemoved;
                    }
                }
        栅栏
            Barrier类似于闭锁，所有事件到达同一位置时才继续执行，即等待其他线程。
            CyclicBarrier 
                CyclicBarrier(int parties) 
                CyclicBarrier(int parties, Runnable barrierAction) 
                    parties为线程数量，barrierAction为所有线程到达后执行内容
                await()
    构建高效可伸缩结果缓存
        public interface Computable<A,V>{ V compute(A arg) throws InterruptedException; }
        public class SomeFunction implements Computable<String, BigInteger> {
            public BigInteger compute(String s){ ...; return xxx; }
        }
        public Memoizer<A,V> implements Computable<A, V> {
            private final ConcurrentMap<A,V> cache = new ConcurrentHashMap<A, FutureTask<V>>();
            private final Computable<A,V> c;
            public Memoizer(Computable<A,V> c){ this.c = c;}
            public V compute(final A arg) throws InterruptedException{
                while(true){
                    Future f = cache.get(arg);
                    if( f==null ){
                        FutureTask<V> ft = new FutureTask<V>(new Callable<V>(){
                            public V call() throws InterruptedException{ return c.compute(arg); }
                        });
                        f = cache.putIfAbsent(arg,ft);//返回arg前一个映射的值，或空值
                        if( f==null){ f=ft; ft.run();}
                    }
                    try{ return f.get(); }
                    catch (CancellationException e){ cache.remove(arg, f); }
                    catch (EcecutionException e){ throw launderThrowable(e.getCause());}
                }
            }
        }
    并发技巧
        尽量声明final，除非需要他们是可变的；
        不可变对象一定是线程安全的；
        封装有助于管理复杂性；
        用锁保护每个可变变量；
        保护同一个不变性条件，用同一个锁；
        复合操作要持有锁；
        在文档中指出非线程安全，或做线程安全的设计；
        同步策略文档化；
****************************************************************

****************************************************************
********************    结构化并发应用程序  ******************** 
****************************************************************

任务执行
    Executor框架
        接口
            public interface Executor{ void execute(Runnable command); }
            使用Runnable作为任务抽象，有局限：不能返回值或抛出受检查的异常-->ExecutorService使用Future做任务抽象
        基于Executor的web服务器
            class TaskExecutionWebServer{
                private static final int NTHREADS = 100;
                private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);
                public static void main(String[] args) throws IOException{
                    ServerSocket socket = new ServerSocket(80);
                    while(true){
                        final Socket connection = socket.accept();
                        Runnable task = new Runnable(){ public void run(){ handleRequest(connetction);} };
                        exec.execute(task);
                    }
                }
            }
        线程池
            Executors中的静态工厂方法创建一个线程池
                newFixedThreadPool 固定长度的线程池，提交一个任务创建一个线程，直到到达设定最大值，规模不再变化（某个线程发生未预期Exception而结束，则会补充一个）
                newCacheThreadPool 规模不受限制，当当前规模超过处理需求，则会回收空闲线程。
                newSingleThreadPool 创建单个线程执行任务，若线程异常而结束，则创建另一个代替之(提供大量同步机制，即使线程不时被替代，总是可以使对象安全的封闭在“任务线程”中)，能确保依照任务在队列中的顺序串行执行。
                newScheduledThreadPool 类似于Timer，固定长度的线程池，以延迟或定时方式执行任务。
        Executor生命周期
            JVM会在所有非守护线程结束后才退出，若无法正确关闭Executor，那么JVM会无法结束
        public interface ExecutorService extends Executor{
            void shutdown();  //平缓的关闭：不在接受任务，等待已经提交(包括尚未开始的)的任务完成.
            List<Runnable> shutdownNow();  //取消所有执行中的任务，并不再启动队列中的任务。
            boolean isShutdown();
            boolean isTerminated();
            boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; //等待ExecutorService进入终止状态
            ...
        }
            关闭后提交的任务由"拒绝执行处理器"处理，是execute方法抛出RejectedExecutionException。
            所有任务完成后，ExecutorService进入终止状态。
            可以调用awaitTermination来等待其到达终止。
        支持关闭的Web服务器
            class LifecycleWebServer{
                private final ExecutorService exec = ...;
                public void start() throws IOException {
                    ServerSocket socket = new ServerSocket(80);
                    while(!exec.isShutdown()){
                        try{
                            final Socket conn = socket.accept();
                            exec.execute(new Runnable(){publi void run(){ handleRequest(conn);}});
                        }catch (RejectedExecutionException e){
                            if(!exec.isShutdown()) log("task submission rejected", e);
                        }
                    }
                }
                public void stop(){ exec.shutdown();}
                void handleRequest(Socket conn){
                    Request req = readRequest(conn);
                    if( isShutdownRequest(req)) stop();
                    else dispatchRequest(req);
                }
            }
        延迟与周期任务
            Timer类：基于绝对时间，因此任务执行对系统时钟变化敏感；
            ScheduledThreadPoolExecutor来代替：基于相对时间调度。
            Timer：只会创建一个线程执行所有定时任务。若任务持续时间过长，则会影响其他TimerTask的定时准确性。例如；周期10ms的任务，若有一个任务执行了40ms，可能此任务执行完后快速连续调用4次或直接失去4次调用。
            若TimerTask抛出一个未检查的异常，则整个Timer被取消。已经被调度但尚未执行的TimerTask不会再执行，新的任务也不能被调度――――"线程泄漏"
                少用Timer
            DelayQueue：只有某个元素逾期之后才能执行take，从DelayQueue中返回的对象根据其延迟时间排序
    可利用的并行性
        串行浏览器渲染程序
            public class SingleThreadRender{
                void renderPage(charSequence source){
                    renderText(source);
                    List<ImageData> imgData = new ArrayList<ImageData>();
                    for(ImageInfo imgInfo = scanForImageInfo(source))
                        imgData.add(imgInfo.downloadImage());
                    for(ImageData data:imgData)
                        renderImage(data);
                }
            }
        Callable与Future接口
            public interface Callable<V>{ V call() throws Exception; }
            public interface Future<V>{
                boolean cancel(boolean mayInterruptIfRunning);
                boolean isCancelled();
                boolean isDone();
                V get() throws InterrptedException, ExecutionException, CancellationException;
                V get(long timeout, TimeUnit unit) throws  InterrptedException, ExecutionException, CancellationException, TimeoutException;
            }
            ExecutorService中的所有submit方法都返回一个Future            
            Executor执行的任务由4个生命周期阶段：创建、提交、开始、完成。已提交但未开始的任务可以取消。但开始的任务只有在响应中断时才能取消。
        使用Future等待图像下载
            public class FutureRender{
                private final ExecutorService executor = ...;
                void renderPage(charSequence source){
                    final List<ImageInfo> infos = scanForImageInfo(source);
                    Callable<List<ImageData>> task = new Callable<List<ImageData>>(){
                        List<ImageData> call(){
                            List<ImageData> result = new ArrayList<ImageData>();
                            for(ImageInfo i : infos) result.add(i.downloadImage());
                            return result;
                        }
                    };
                    Future<List<ImageData>> future = executor.submit(task);
                    renderText(source);
                    try{
                        List<ImageData> imgData = future.get();
                        for(ImageData data:imgData)
                            renderImage(data);
                    }catch (InterruptedException e){
                        Thread.currentThread().interrupt(); //重新设置中断状态
                        future.cancel(true);  //不再需要结果，故取消
                    }catch (ExcutionException e){ throw launderThrowable(e.getCause()); }
                }
            }
        异构任务在并行化中存在的局限
            在上个例子中，渲染页面与图像下载是两个不同类型的任务。在任务类型不同时，可能出现任务大小不同而出现性能提升并不大的情况。即当渲染页面速度远小于下载图像时，程序最终的性能与串行执行差别并不大
        CompletionService: Executor + BlockingQueue
            向Executor提交一组计算任务，并且希望计算后取得结果；可以保留与每个任务相关联的Future，反复使用get方法(将timeout指定为0，通过轮训来判断任务是否完成)。
            CompletionService将Executor与BlockingQueue融合：将Callable任务提交给它执行，后使用类似于队列操作的take（阻塞）与poll（空值)方法取得已完成的结果，这些结果会在完成时封装为Future。
            ExecutorCompletionService：在构造函数中创建一个BlockingQueue来保存计算完成结果；计算完成时调用Future-Task中的done方法；在任务提交时，将其包装为一个QueueingFuture（extend FutureTask），改写了其done方法，将结果放入BlockingQueue

            public class Render{
                private final ExecutorService executor = ...;
                void renderPage(charSequence source){
                    final List<ImageInfo> infos = scanForImageInfo(source);
                    ExecutorCompletionService<ImageData> completionService = new ExecutorCompletionService<ImageData>(executor);
                    for(final ImageInfo i : infos) 
                        completionService.submit(new Callable<ImageData>(){public ImageData call(){ return i.downloadImage(); }});    
                    Future<List<ImageData>> future = executor.submit(task);
                    renderText(source);
                    try{
                        for(int i=0;i<infos.size(); t++){
                            Future<ImageData> imgFuture = completionService.take();
                            ImageData img= imageFuture.get();
                            renderImage(img);
                    }catch (InterruptedException e){
                        Thread.currentThread().interrupt(); //重新设置中断状态
                    }catch (ExcutionException e){ throw launderThrowable(e.getCause()); }
                }
            }
        任务的时限
            //广告案例：超时则显示默认广告
            try{
                long timeLeft = endNanos - System.nanoTime();
                Ad ad = future.get(timeLeft,NANOSECONDS);
            } catch (ExecutionException e){ ad = DEFAULT_AD;}
            catch (TimeoutException e){ad = DEFAULT_AD; f.cancel(true);}
            ExecutorService中
            List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)  按照任务集合中，迭代器的顺序将Future提交到返回的集合中

*********
* 取消与关闭*
*************
    任务取消
            用户请求取消：点击图形界面的"取消"按钮
            时限操作：超时取消所有任务
            应用程序事件：对某问题进行分解并搜索，当其中一个任务找到解决放弃，其他任务都应取消。
            错误：如爬虫任务并存盘，当一个任务发生错误如磁盘满，那所有任务都会取消，保存现有状态，以便重新启动。
            关闭：应用程序或服务关闭时，必须对正在处理以及待处理任务执行某种操作
         java没有一种安全的抢占式方法停止线程,只有一些协作的机制。
         使用volatile域来保存取消状态
             @ThreadSafe
             public class PrimeGenerator implements Runnable{
                @GuardedBy("this")
                private final List<BigInteger> primes = new ArrayList<BigInteger>;
                private volatile boolean cancelled;
                public void cancel(){ cancelled = true; }
                public void run(){ 
                    BigInteger p = BigInteger.ONE;
                    while(!cancelled){
                        p=p.nextProbablePrime();
                        synchronized(this){primes.add(p);}
                    }
                }
                public synchronized List<BigInteger> get(){
                    return new ArrayList<BigInteger>(primes);
                }
            }

        中断
            调用interrupt并不意味着立即停止线程，而只是传递了中断消息
                public class Thread{
                    public void interrupt(){...}
                    public boolean isInterrupted(){...}
                    public static boolean interrupted(){...} //清除并返回当前的中断状态
                }
            若上例中使用BlockingQueue代替List，任务可能无法检查取消标志而无法结束：当生产者速度超过消费者，队列被填满，queue.put(xxx)将会阻塞，其他线程即使调用cancel企图取消任务时，由于阻塞的存在而使线程无法到达检查代码的位置，而无法退出线程。
            当线程在非阻塞状态下中断，中断状态被设置，如果不触发InterruptedException，那么中断状态一直保持，直到明确地清除之。
          使用中断取消
             public class PrimeProducer extends Thread{
                private final BlockingQueue queue ;
                public PrimeProduce(BlockingQueue q){this.queue = q;}
                public void cancel(){ interrupt(); }
                public void run(){ 
                    try{
                        BigInteger p = BigInteger.ONE;
                        while(!Thread.currentThread().isInterrupted())
                            queue.put(p=p.nextProbablePrime());
                    }catch(InterruptedExecption e){/*允许线程退出*/}
                }
            }
        中断策略
            线程级或服务级的取消操作，尽快退出，在必要时进行清理，通知某个所有者该线程已退出。
            如果出了将InterruptedException传递给调用者外还需要执行其他操作，那么应该在捕获InterruptedException之后恢复中断状态
                Thread.currentThread().interrupt();
            除非知道中断对于一个线程的意义，否则就不该中断该线程
        响应中断
            传递异常：(可能在执行某个特定任务清除操作之后) 从而使你的方法成为可中断的阻塞方法
            恢复中断状态：从而使调用栈中的上层代码能够对其进行处理
            只有实现了中断策略的代码可以屏蔽中断请求，在常规任务与库代码中都不应屏蔽中断请求。
            如果不想或无法传递InterruptedException（通过Runnable）定义任务，那么需要寻找另一种方式保存中断请求，一种标准的方法就是再次调用interrupt来恢复中断状态。
            不可取消的方法中调用可中断的阻塞方法时：在循环中调用该可中断阻塞方法，发现中断后保存中断状态，并重新尝试；在返回前恢复中断状态，从而告知调用者发生了中断
                public Task getNextTask(BlockingQueue<Task> queue){//所谓不可取消指方法本身
                    boolean interrupted = false;
                    try{
                        while(true){
                            try{return queue.take();}
                            catch (InterruptedException e){ interrupted = true; }//保存状态并重试
                        }
                    }finally{
                        if(interrupted) Thread.currentThread.interrupt(); //
                    }




            
