常用命令
    文件夹
        cd x
            ~家
            -上一个工作目录
            .为当前目录
            ..为上层目录
        pwd [-P真实路径即非链接表示的路径]输出当前目录
        ls -al 通常alias为 ll
        mkdir [-p建立上层] dir3
        mkdir -m 777 dir4
        rm xxx 
        rmdir [-p删除也为空的上层] 删除空文件夹
        mv fromdir todir
        chmod a+x filename
            a为all 还可以是u=user，g=group，o=other
            +为增加权限还可以-
            x为执行还可以是r=read，w=write
        chmod [-R] 777 file
            r=4,w=2,x=1
            -R 为递归  
        ln 实体链接
            ln fileA fileB 文件A必须存在 文件B必须不存在 从此AB是一个文件的不同入口，修改同步，名字不同，删除一个另一个仍会存在
            ll fileA fileB 会显示两个相同的iNode
            ln -s fileA fileASymolickLink A若是被删除，则符号链接无法打开，A也可以是目录
            新建目录的link数为2，新建目录时，该目录的上层目录的link+1
                /tmp/test    link到本身
                /tmp/test/.  link到本身
                /tmp/tets/.. link到tmp
        du -sh 目录的占容量
            du -s * | sort -nr | head 
    文件    
        cat一次显示 more逐行显示 less上下翻页（/搜索nN上下一个，gG头尾），head与tail -n number filename
        touch建立空文件，或修改文件时间
        file filename 文件信息
        find / -name passwd
        find / -name "*passwd"
        tar -xzvf xxx.tar.gz
            -czvf xxx.tar.gz xxxfile
    磁盘 分区 挂载
        df -h 磁盘使用情况
           -i iNode使用情况
        lsblk 磁盘列表
        blkid 磁盘uuid
        parted /dev/sdb1 print 列出磁盘的分区表类型与分区信息
        gdisk fdisk 分区工具 MBR用fdisk GPT用gdisk
        mkfs 建立文件系统 即格式化
            mkfs.xfs mkfs.ext4...
        mount [-t 文件系统种类] 装置名 挂载点
            -o iocharset=utf8 编码类型
            -t 几乎不需要指明类型，已经可以自己判断     
            mount -a 的配置文件/etc/fstab  
    
vim
    进入命令模式
        : / ?
    光标移动
        左下上右hjkl
            20j向下移动20行
            n<enter>
        跳转到本行第n个字符
            n<space>
        行内首
            0 或 [home]键
            尾
            [end] 或 $
        翻页
            Ctrl+f 等价 [PageDown]  ; Ctrl+d 向下半页
            Ctrl+b 等价 [PageUp]    ; Ctrl+u 向上半页
        屏幕位置
            最上方  H
            中央    M
            最下方  L
        文件位置
            nG 文件第n行
            gg 文件第一行
            G 文件尾
        搜索
            /word 向光标以后寻找word
            ?word 向光标之前寻找word
            n N 下一个 上一个
    进入编辑模式
        i a o r
            o下一行插入新行 O上一行插入新行
            r替代一个字符   R持续替代字符相当于word里的insert键
    更动
        替换
            :n1,n2s/word1/word2/g[c] 将n1到n2行间的word1替换为word2
                n2可以是$,表示最后一行
                最后可选的c表示让用户确认是否替代
        光标所在处为当前闪烁字符的左侧
        删除
            x   相当于[delete]
            X   相当于[backspace]
            nx  向后删除n个字符
            dd  删除整行
            ndd 删除n行
            d1  G删除光标所在至第一行
            dG  删除光标所在至最后
            d0  行内删除到第一个字符
            d$  行内删除到最后一个字符
            c20j
            c21l 用c删除后就进入插入模式了
        复制
            yy 当前行
            nyy 当前行向下n行（包括当前行）
            y1G 当前一行至第一行    
            yG  当前一行至最后一行
            y0  行内复制到行首
            y$  行内复制
        可视模式
            v 行内选择
            V 行选择
            Ctrl+v 长方形选择
            y 选中部分复制
            d         删除   
            p 可以方形复制
        粘贴
            p下一行     行内粘贴时粘贴到当前字符右侧
            P到上一行   行内粘贴时粘贴到光标处
        撤销与重做
            u 撤销
            Ctrl+r 重做    
            . 重复上一个动作
    保存退出
        :w 写入
        :w! 强行写入
        :q 
        :q! 离开并不存储
        :wq 存储并离开
        ZZ  自动离开 更动则存储 
        :w [filename] 另存为
        :r [filename] 将此文件中的内容加到光标所在行的下一行
        :n1,n2 w [filename] 将n1到n2的内容保存为一个文件
        :! command 暂时离开vi 执行command 显示结果
        :set [nu|nonu]  设置或取消行号
    多窗口
        :sp [filename]
        Ctrl+w, j/k 切换窗口
        Ctrl+w, q 退出
    自动补全
        Ctrl+x,Ctrl+n 以正在编辑的文字为关键字补齐
        Ctrl+x,Ctrl+o 以文件拓展名语法补齐
        Ctrl+x,Ctrl+f 以当前目录下的文件名为补齐目标
    转换编码
        file fileName 查看文件编码
        iconv -f big5 -t utf8 filename [-o newfile]
        iconv --list 列出支持的语系
    回车符转换
        dos2unix 
        unix2dos [-kn] file [newfile]
            -n保留旧文件转换内容到新文件
            -k保留文件原本的mtime时间
开始bash
    编辑
        Ctrl+ae 移动光标到行首尾
        Ctrl+uk 删除光标前后内容
    变量
        由字母与数字与下划线组成，开头不可是数字
        =直接赋值，左右不可由空格，如var1=xxx    
        取用变量使用$符号，如echo var1; 输出xxx
        双引号内的东西有其原有特性，如var2="var1 is $var1" ;echo $var2;其结果是var is xxx
            若是单引号，则表示为普通字符串 var4='var1 is not $var1';echo $var4;结果为var1 is not $var1
        跳脱字符\，如var3=var2\ haha3;echo var3; 其结果var2 haha3。可以用作换行
        若变量设置时需要一些命令的结果可以用`command`或者$(command)如var5="print working dir:`pwd`";结果为print working dir: /home/morris
        拓展变量内容 PATH=${PATH}:/home/bin或者PATH="$PATH":home/bin
        unset var5取消var5的设置 set命令可以展示现有变量
        $本身也是变量，表示shell的PID。echo $$输出15983
        ?也是变量，表示上个指令的回传值，成功的指令为0
        read 接受键盘输入的一行字符到一个变量中去
        declare 宣告变量类型，没有参数时=set
            -a 数组
            -i 数字，整数，bash内的运算只能是整数1/2=0
            -x 等同于export，将变量变为环境变量
            -r 只读类型，不可更改且不能unset
        数组 var[1]=aaa var[2]=bbb var[3]=ccc  echo ${var[1]}        
	命令别名
	    type ls 查询ls是否內建 找出执行档
	    alias ll='ls -alF'  （默认的）
	    aliad lm='ls -al | more'
	    unalias lm
	用户资源限制 ulimit
	    -a 列出所有限制
	    -SH 警告设定与限制设定 -u 最大process数量
	    -f 最大文件容量        -d 程序可使用最大内存分段segment
	    -l 用于锁定的内存量    -t 最大cpu时间单位秒
	    -c 核心文件(当程序出错，系统可以将内存中的信息写成文件)的最大容量
    编辑
        删除
            #,##从左向右删除 单个的表示只匹配最短
            %,%%从右向左删除 两个的表示匹配最长
                path=$PATH;  echo ${path#/*:} ; echo ${path##/*:};百分号则反向匹配
                echo ${path%%:/usr*} 
        替换
            ${path//morris/Morris} 可以把Morris去掉用以删除，同样的可以用单个/表示只删除一个
            
        空判断与赋值
            var=${str[:][+-=?]expr}
            str  表示是否str没有定义
            str: 表示是否str没有定义或定义为空字符串
            +是则为str，否则为expr
            -与+相反
            =是则str赋值为expr，否则str不变，后在var=str
            ?是则expr输出至stderr，否则var=str
    命令历史 history
	    history 10 最近10条
	        -c 清楚当前shell中的history
        history [-arw] xxxfile
            -a 当前新增的加入到xxx中去 没有指定xxx则写入~/.bash_history
            -r 读取xxx中的内容到history中
            -w 当前history写入到文件
        !xxx 向前搜索开头为xxx的命令并执行
        !!   相当于按↑再回车
    欢迎界面文字
        /etc/issue
        \d本地端时间的日期;     \l显示第几个终端机接口;  \m显示硬件的等级 (i386/i486/i586/i686...);
        \n显示主机的网络名称;   \O显示 domain name;     \r操作系统的版本 (相当于 uname -r)
        \t显示本地端时间的时间; \S操作系统的名称;        \v操作系统的版本
    bash环境配置文件               
        login shell 需要登录密码流程的
            /etc/profile 系统整体设定
                PATH:依据 UID 决定 PATH 变量要不要含有 sbin ;MAIL:依据账号设定好使用者的 mailbox到 /var/spool/mail/账号名; USER:根据用户的账号设定此一变量内容;HOSTNAME:依据主机的 hostname 指令决定此一变量内容; HISTSIZE:历史命令记录笔数。umask:包括 root 默认为 022 而一般用户为 002 等!
            ~/.bash_login或~/.profile 用户设定
        no-login shell bash中再bash没有需要密码 X window登入没有需要密码
    终端环境stty
        stty -a 
        stty intr ^C 中断设置为Ctrl+C（默认就是这个）
    特殊字符
        []*?以及“[-]”表示编码序列内的字符以及“[^]”反选序列 表示通配
        #注释
        \转义
        |管道
        ;连续指令分割
        ~用户家目录
        $取变量
        &工作控制，将指令变为背景下工作
        !逻辑非
        > >> < << 数据流重导向
        '' $作为文本
        ""保留$的功能
        ``先执行指令
        ()子shell的起始与结束
        {}命令区块组合 
    数据流  
        1. 标准输入 (stdin) :代码为 0 ,使用 < 或 << ;
        2. 标准输出 (stdout):代码为 1 ,使用 > 或 >> ;文件不存在则建立
        3. 标准错误输出(stderr):代码为 2 ,使用 2> 或 2>>
            垃圾黑洞 /dev/null 如xxcommand xxarg 2> /dev/null将错误信息丢弃
        单个符号表示覆盖，多个表示累加
	        例 ll /etc > ~/rootfilelist  
	           find /home -name .bashrc > list_right 2> list_error 
	            #正确与错误信息分别输入不同文件
        写入同一个文件的特殊语法:可以使用 2>&1 也可以使用 &>
	        常规写法...... > list 2> list
	        特殊写法...... > list 2>&1
	                       &> list
	        写入同一个文件由于两股数据留交叉，会造成次序混乱
        键盘输入创建文件
	        cat > catfile 
	            [输入内容，ctrl+D结束]
	        cat > catfile <<"eof"
	            [输入内容，以"eof"结束]
    连续指令
        不相干	sync; sync; shutdown -h now
        正确则继续  cd ~ && cat .bashrc   
        不成功则继续  ls abc.txt || touch abc.txt
    管线
	    cmd1 | cmd2
	    管线命令仅会处理 standard output,对于 standard error output 会予以忽略
	    管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行
    截取
        cut 截取出行内我们想要的数据
	        cut -d '分隔字符' -f '数字表示的段,逗号间隔'
	        cut -c 12-20 以字符为单位列出第12到第20
	            不太适合处理多空格相连的数据
        grep 分析行信息，只取需要的行
	        grep [-acinv] [--color=auto] '搜寻字符串' filename
		    a 将binary文件以text方式搜寻
		    c 计算次数  i 忽略大小写  n 输出行号  v 反向选择
            last | grep 'morris' |cut -d ' ' -f 1 #最近登录的账户
    排序
        sort [-f..] [file or stdin]
        -f :忽略大小写的差异,例如 A 与 a 视为编码相同;
        -b :忽略最前面的空格符部分;
        -M :以月份的名字来排序,例如 JAN, DEC 等等的排序方法;
        -n :使用『纯数字』进行排序(默认是以文字型态来排序的);
        -r :反向排序;
        -u :就是 uniq ,相同的数据中,仅出现一行代表;
        -t :分隔符,预设是用 [tab] 键来分隔;
        -k :以那个区间 (field) 来进行排序的意思
        uniq 去重 -i忽略大小写 -c 计数
        wc 字数统计 -l 列出行数 -w 列出单词英数 -m 字符数
    双向重导向
        即分流出来
        

	    





        


    
    





正则表达式
    
    LANG=C
        编码顺序会对正则有影响[A-Z]在一些语系中会包含小写字母
    grep
        -An 即After除本行外后续的n行也显示出来
        -Bn 即Before除本行外前面的n行也显示
        -v 反选
            xxx | grep -v '^$' #不要空行
    [] 匹配一个[]表示的集合中的字符，除下述的形式外，可以更一般的使用[mnpq]表示集合
--------------------------------------------------------------------------------------
        [:alnum:] 0-9a-bA-B     [:alpha:] a-bA-B        [:blank:] 空格与tab
        [:digit:] 0-9           [:xdigit:] 16进制数字符 [:gragh:] 除去空格与tab外的所有
        [:lower:] a-b           [:punct:] 标点          [:space:] 任何产生空格的字符
        [:upper:] A-B           [:cntrl:] CR..等控制字符[:print:] 任何可以被打印的字符
--------------------------------------------------------------------------------------
        [:digit:] 代表0-9。故需要匹配数字时需要写成[[:digit:]]。其他的同理
    行首行尾
        ^ $会有dos与unix的断行方式的干扰
    单个字符的重复
        .表示任意一个字符
        *表示重复左边的字符0次或多次
        +表示字符出现至少一次
        ?表示字符至多出现一次
            a*b匹配  b，ab，aaaaaaab ……
            a+b匹配     ab，aaab ……
            a?b匹配     ab，b。
        {n}，{n,}，{n,m} 重复n次，n次以上，n到m次
    匹配组
        (pattern) 匹配并获取此匹配到匹配组集合
        (?:pattern) 匹配 pattern 但不获取匹配结果，
            在匹配“abc或abd”两种之一时，可以写为abc|abd ，使用这里的方式可简写为ab(?:c|d)
        (?=pattern) 正向肯定预查，Morris(?=1|2|7)


